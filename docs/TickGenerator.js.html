<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: TickGenerator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: TickGenerator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/** @namespace */
var cr = cr || {};

/**
 * Creates a &lt;code>TickGenerator&lt;/code> with the given &lt;code>tickSize&lt;/code> and &lt;code>offset&lt;/code>.
 *
 * @class
 * @constructor
 * @private
 * @param {number} tickSize
 * @param {number} offset
 */
cr.TickGenerator = function(tickSize, offset) {
    this._tickSize = tickSize;
    this._offset = offset;
    this._currentTick = 0.0;
};

cr.TickGenerator.prototype.nextTick = function(min) {
    if (min) {
        this._min = min;
        this._currentTick = this.closestTick(min - this._tickSize);
        while (this._currentTick &lt; min) {
            this.advanceTick();
        }
    }
    else {
        this.advanceTick();
    }
    return this._currentTick;
};

cr.TickGenerator.prototype.advanceTick = function() {
    this._prevTick = this._currentTick;
    this._currentTick = this.closestTick(this._currentTick + this._tickSize);
    if (this._currentTick &lt;= this._prevTick) {
        // This seems to happen if we've zoomed so very far that we don't have sufficient precision to advance
        // the tick.
        // Compute a tiny amount guaranteed to advance the tick.  This won't land in the right spot for a real
        // tick, but at least will prevent an infinite loop.
        var tickAdvance = Math.max(Math.abs(this._prevTick) / Math.pow(2, 50), Number.MIN_VALUE);
        this._currentTick = this._prevTick + tickAdvance;
    }
};

cr.TickGenerator.prototype.closestTick = function(val) {
    return Math.round((val - this._offset) / this._tickSize) * this._tickSize + this._offset;
};

cr.TickGenerator.closestDay = function(time) {
    var timeDate = new Date(time * 1000);
    var hour = timeDate.getHours() + timeDate.getMinutes() / 30.0 + timeDate.getSeconds() / 1800.;
    if (hour >= 12) {
        // Advance day by moving to one min before midnight
        timeDate.setHours(23);
        timeDate.setMinutes(59);
        timeDate.setSeconds(59);
        // Advance 12 hours
        timeDate.setTime(timeDate.getTime() + 60 * 60 * 12 * 1000);
    }
    // Truncate to beginning of day
    timeDate.setHours(0);
    timeDate.setMinutes(0);
    timeDate.setSeconds(0);
    var epsilon = 1e-10;
    // Return time in seconds, truncating fractional second
    var ret = Math.floor(timeDate.getTime() / 1000 + epsilon);
    return ret;
};

cr.DayTickGenerator = function(tickSize, offset) {
    cr.TickGenerator.call(this, tickSize, offset);
};
cr.DayTickGenerator.prototype = Object.create(cr.TickGenerator.prototype);

cr.DayTickGenerator.prototype.closestTick = function(time) {
    return cr.TickGenerator.closestDay(time);
};

cr.WeekTickGenerator = function(tickSize, offset) {

};
cr.WeekTickGenerator.prototype = Object.create(cr.TickGenerator.prototype);

cr.WeekTickGenerator.prototype.closestTick = function(time) {
    var timeDate = new Date(time * 1000);

    var day = ((60 * (60 * timeDate.getSeconds()) + timeDate.getMinutes()) + timeDate.getHours()) / 24.;
    var daysSinceMonday = timeDate.getDay() - 1;

    if (daysSinceMonday &lt; 0) {
        daysSinceMonday += 7;
    }

    day += daysSinceMonday;

    if (day >= 3.5) {
        return cr.TickGenerator.closestDay(time + cr.TimeConstants.SECONDS_IN_DAY * (7 - day));
    }
    else {
        return cr.TickGenerator.closestDay(time - cr.TimeConstants.SECONDS_IN_DAY * day);
    }
};

cr.MonthTickGenerator = function(tickSize, offset) {
    cr.TickGenerator.call(this, cr.TimeConstants.SECONDS_IN_MONTH * tickSize, offset);
    this._tickSizeMonths = tickSize;
};
cr.MonthTickGenerator.prototype = Object.create(cr.TickGenerator.prototype);

cr.MonthTickGenerator.prototype.closestTick = function(time) {
    var timeDate = new Date(time * 1000);
    var monthsSince1900 = timeDate.getYear() * 12
                          + timeDate.getMonth()
                          + (timeDate.getDate() * cr.TimeConstants.SECONDS_IN_DAY / cr.TimeConstants.SECONDS_IN_MONTH);
    var tickMonthsSince1900 = Math.round(monthsSince1900 / this._tickSizeMonths) * this._tickSizeMonths;
    var tickYear = Math.floor(tickMonthsSince1900 / 12);
    var tickMonth = tickMonthsSince1900 - tickYear * 12;
    var tickDate = new Date(tickYear + 1900, tickMonth, 1);
    return Math.round(tickDate.getTime() / 1000);
};

cr.YearTickGenerator = function(tickSize, offset) {
    cr.MonthTickGenerator.call(this, tickSize * 12, offset);
};
cr.YearTickGenerator.prototype = Object.create(cr.MonthTickGenerator.prototype);

cr.HourTickGenerator = function(tickSize) {
    cr.TickGenerator.call(this, cr.TimeConstants.SECONDS_IN_HOUR * tickSize, 0);
    this._tickSizeHours = tickSize;
};
cr.HourTickGenerator.prototype = Object.create(cr.TickGenerator.prototype);

cr.HourTickGenerator.prototype.closestTick = function(time) {
    var timeDate = new Date((time * 1000));
    var hour = timeDate.getHours() + timeDate.getMinutes() / 30.0 + timeDate.getSeconds() / 1800.0;

    var closestHour = Math.round(hour / this._tickSizeHours) * this._tickSizeHours;
    if (closestHour == 24) {
        // Midnight of next day.  Advance time and return closest
        // beginning of day
        return cr.TickGenerator.closestDay(time + (24 - hour) * cr.TimeConstants.SECONDS_IN_HOUR);
    }
    else {
        timeDate.setHours(closestHour);
    }

    // Remove minutes and seconds
    timeDate.setMinutes(0);
    timeDate.setSeconds(0);
    var epsilon = 1e-10;
    // Return time in seconds, truncating fractional second
    return Math.floor(timeDate.getTime() / 1000 + epsilon);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="cr.Basis.html">Basis</a></li><li><a href="cr.GraphAxis.html">GraphAxis</a></li><li><a href="cr.Grapher.html">Grapher</a></li><li><a href="cr.Plot.html">Plot</a></li><li><a href="cr.SeriesPlotContainer.html">SeriesPlotContainer</a></li><li><a href="cr.TileIdx.html">TileIdx</a></li><li><a href="cr.TimeGraphAxis.html">TimeGraphAxis</a></li><li><a href="cr.TouchUtils.html">TouchUtils</a></li><li><a href="cr.Uuid.html">Uuid</a></li><li><a href="DataSeriesPlot.html">DataSeriesPlot</a></li><li><a href="DateAxis.html">DateAxis</a></li><li><a href="NumberAxis.html">NumberAxis</a></li><li><a href="PlotContainer.html">PlotContainer</a></li></ul><h3>Namespaces</h3><ul><li><a href="cr.html">cr</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Thu Oct 15 2015 10:18:38 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
