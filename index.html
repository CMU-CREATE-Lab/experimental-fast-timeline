<html>
<head>
<meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css">
<style>
body {
  margin: 0px;
}
.ui-state-active {
  font-weight: bold;
}
</style>
<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<script src="js/jquery.mousewheel.min.js"></script>
<script src="data.js"></script>
<script src="js/fpsmeter.min.js"></script>
<script>

var canvas, bounds, view, meter;

function init() {
  meter = new FPSMeter({graph:1});
  canvas = $('#canvas')[0];
  $('.buttonset').buttonset();
  $("input[name=count]:radio").click(setWidth);
  bounds = {xmin: Number.MAX_VALUE, xmax: -Number.MAX_VALUE, ymin: Number.MAX_VALUE, ymax: -Number.MAX_VALUE};
  for (var i = 0; i < data.length; i += 2) {
    bounds.xmin = Math.min(bounds.xmin, data[i + 0]);
    bounds.xmax = Math.max(bounds.xmax, data[i + 0]);
    bounds.ymin = Math.min(bounds.ymin, data[i + 1]);
    bounds.ymax = Math.max(bounds.ymax, data[i + 1]);
  }
  view = {xmin: bounds.xmin, xmax: bounds.xmax, ymin: bounds.ymin, ymax: bounds.ymax};
  setWidth();

  $(window).resize(resize);
  $(window).scroll(resize);
  $('#canvas').bind('orientationchange', resize);

  $('#canvas').mousedown(mousedown);
  $('#canvas').mousemove(mousemove);
  $('#canvas').mouseup(mouseup);
  $('#canvas').mousewheel(mousewheel);
  $('#canvas').bind('touchstart', touchstart);
  $('#canvas').bind('touchmove', touchmove);
  $('#canvas').bind('touchend', touchend);
  $('#canvas').bind('touchcancel', touchend);

  resize();
  redraw();
}

var lastTouch = null;

function touchstart(e) {
  lastTouch = e.originalEvent.touches;
  return false;
}

function copyTouches(touches) {
  var ret = [];
  for (var i = 0; i < touches.length; i++) {
    ret.push({clientX: touches[i].clientX, clientY: touches[i].clientY});
  }
  return ret;
}

function centroid(touches) {
  var ret = {clientX:0, clientY:0};
  for (var i = 0; i < touches.length; i++) {
    ret.clientX += touches[i].clientX;
    ret.clientY += touches[i].clientY;
  }
  ret.clientX /= touches.length;
  ret.clientY /= touches.length;
  return ret;
}

function xSpan(touches) {
  return Math.abs(touches[0].clientX - touches[1].clientX);
}

function ySpan(touches) {
  return Math.abs(touches[0].clientY - touches[1].clientY);
}

function isXPinch(touches) {
  return touches.length == 2 && xSpan(touches) > ySpan(touches);
}

function touchmove(e) {
  var thisTouch = e.originalEvent.touches;
  if (lastTouch && thisTouch.length == lastTouch.length) {
    translatePixels(centroid(thisTouch).clientX - centroid(lastTouch).clientX);
    if (isXPinch(thisTouch) && isXPinch(lastTouch)) {
      zoomAbout(centroid(thisTouch).clientX, xSpan(thisTouch) / xSpan(lastTouch));
    }
  }
  // Some platforms reuse the touch list
  lastTouch = copyTouches(thisTouch);
  return false;
}

function touchend(e) {
  lastTouch = null;
  return false;
}

var lastMouse = null;

function mousedown(e) {
  lastMouse = e;
  return false;
}

function translatePixels(dx) {
  var xScale = canvas.width / window.devicePixelRatio / (view.xmax - view.xmin);
  view.xmin -= dx / xScale;
  view.xmax -= dx / xScale;
  limitView();
}

// scale > 1 means "zoom in"
function zoomAbout(pixelX, scale) {
  // Limit scale to not zoom out past "width"
  var width = view.xmax - view.xmin;
  if (width / scale > maxWidth()) {
    scale = width / maxWidth();
  }
  // Zoom about pixelX
  var x = pixelToX(pixelX);
  view.xmin -= x;
  view.xmax -= x;
  view.xmin /= scale;
  view.xmax /= scale;
  view.xmin += x;
  view.xmax += x;

  limitView();
}

function mousemove(e) {
  // If mouse button is up, we probably missed the up event when the mouse was outside
  // the window
  if (!e.which) {
    mouseup(e);
    return;
  }
  
  if (lastMouse) {
    translatePixels(e.clientX - lastMouse.clientX);
  }
  lastMouse = e;
  return false;
}

function mouseup(e) {
  lastMouse = null;
}

function mousewheel(e) {
  zoomAbout(event.clientX, Math.pow(1.0005, event.deltaY));
  return false;
}

function resize() {
  console.log('Resizing body to ' + window.innerWidth + ' x ' + window.innerHeight);
  $('body').width(window.innerWidth);
  $('body').height(window.innerHeight);
  document.body.scrollLeft=0;
  document.body.scrollTop=0;
  canvas.width = window.innerWidth * window.devicePixelRatio;
  canvas.height = window.innerHeight * window.devicePixelRatio;
  console.log('Resized canvas to ' + canvas.width + ' x ' + canvas.height);
}

// Set width to requested value    
function setWidth() {
  var width = 3600 * ($('input:radio[name=count]:checked').attr('id') == 'count1k' ? 1000 : 5000);
  var xcenter = (view.xmin + view.xmax) / 2;
  view.xmin = xcenter - width / 2;
  view.xmax = xcenter + width / 2;
  limitView();
}

function maxWidth() {
}

function limitView() {
  if (view.xmax - view.xmin > bounds.xmax - bounds.xmin) {
    // Tried to zoom out beyond bounds
    view.xmax = bounds.xmax;
    view.xmin = bounds.xmin;
  } else if (view.xmin < bounds.xmin) {
    // Tried to pan too far left                            
    view.xmax += bounds.xmin - view.xmin;
    view.xmin = bounds.xmin;
  } else if (view.xmax > bounds.xmax) {
    // Tried to pan too far right
    view.xmin -= view.xmax - bounds.xmax;
    view.xmax = bounds.xmax;
  }
}

function redraw() {
  meter.tick();
  //if ($('input:radio[name=method]:checked').attr('id') == '2d') {
  //  redrawCanvas();
  //} else {
  //  redrawWebGL();
  //}
  redrawCanvas();
  window.requestAnimationFrame(redraw);
}

function pixelToX(px) {
  var xOffset = -view.xmin;
  var xScale = canvas.width / (view.xmax - view.xmin);
  return px / xScale - xOffset;
}

function redrawCanvas() {
  //console.log('redrawCanvas');
  var ctx = canvas.getContext('2d');
  ctx.clearRect (0, 0, canvas.width, canvas.height);
  
  var xOffset = -view.xmin;
  var xScale = canvas.width / (view.xmax - view.xmin);
  var yOffset = -view.ymax;
  var yScale = canvas.height / (view.ymin - view.ymax);

  // Find the first element >= xmin
  var min = 1, max = data.length / 2 - 1;
  while (min < max) {
    var test = Math.floor((min + max) / 2);
    if (data[test * 2] >= view.xmin) {
      max = test;
    } else {
      min = test + 1;
    }
  }
  var begin = min - 1;

  // Find the last element <= xmax
  var min = 0, max = data.length / 2 - 2;
  while (min < max) {
    var test = Math.ceil((min + max) / 2);
    if (data[test * 2] <= view.xmax) {
      min = test;
    } else {
      max = test - 1;
    }
  }
  var end = max + 1;

  $('#numSegments').text(end - begin + 1 + ' segments');

  for (var i = begin; i <= end - 1; i++) {
    ctx.beginPath();
    ctx.moveTo(xScale * (data[i * 2 + 0] + xOffset), yScale * (data[i * 2 + 1] + yOffset));
    ctx.lineTo(xScale * (data[i * 2 + 2] + xOffset), yScale * (data[i * 2 + 3] + yOffset));
    ctx.stroke();
  }
}
function redrawWebGL() {
  console.log('redrawWebGL');
}
$(init);
</script>
</head>
<body>
<canvas id="canvas" style="width:100%; height:100%"></canvas>
<div style="position:absolute; right: 3px; top: 9px">
<span class="buttonset">
<input type="radio" name="count" id="count1k" checked="checked"><label for="count1k">1K</label>
<input type="radio" name="count" id="count5k"><label for="count5k">5K</label>
</span>
<!--<span class="buttonset">
<input type="radio" name="method" id="2d" checked="checked"><label for="2d">canvas</label>
<input type="radio" name="method" id="3d"><label for="3d">webgl</label>
</span>-->
</div>
<div id="numSegments" style="position:absolute; left: 10px; top: 60px; font-size: 18pt"></div>
</body>
</html>


